#!/usr/bin/env zsh
# ============================================================
# pre-commit - Git Pre-Commit Hook fÃ¼r dotfiles
# ============================================================
# Zweck       : Verhindert Commits mit veralteter Dokumentation,
#               ungÃ¼ltiger Shell-Syntax oder falscher Formatierung
# Pfad        : .github/hooks/pre-commit
# Install     : git config core.hooksPath .github/hooks
# WICHTIG     : --no-verify ist VERBOTEN (siehe copilot-instructions.md)
# ============================================================

set -uo pipefail

SCRIPT_DIR="${0:A:h}"
DOTFILES_DIR="${SCRIPT_DIR:h:h}"  # .github/hooks â†’ dotfiles
SHELL_COLORS="$DOTFILES_DIR/terminal/.config/theme-style"

# Farben (Catppuccin Mocha) â€“ zentral definiert
[[ -f "$SHELL_COLORS" ]] && source "$SHELL_COLORS"

# Logging (konsistent mit anderen Skripten)
log()  { echo -e "${C_BLUE}â†’${C_RESET} $1"; }
ok()   { echo -e "${C_GREEN}âœ”${C_RESET} $1"; }
warn() { echo -e "${C_YELLOW}âš ${C_RESET} $1"; }
err()  { echo -e "${C_RED}âœ–${C_RESET} $1" >&2; }

# ------------------------------------------------------------
# 1. Shell-Syntax prÃ¼fen
# ------------------------------------------------------------
check_shell_syntax() {
    log "PrÃ¼fe Shell-Syntax..."
    local errors=0

    # Alle .sh, .alias und .zsh Dateien prÃ¼fen
    for file in "$DOTFILES_DIR"/.github/scripts/**/*.sh(N) \
                "$DOTFILES_DIR"/terminal/.config/alias/*.alias(N) \
                "$DOTFILES_DIR"/terminal/.config/zsh/*.zsh(N) \
                "$DOTFILES_DIR"/terminal/.zsh*(N) \
                "$DOTFILES_DIR"/terminal/.zprofile(N) \
                "$DOTFILES_DIR"/terminal/.zlogin(N) \
                "$DOTFILES_DIR"/setup/*.sh(N) \
                "$DOTFILES_DIR"/setup/modules/*.sh(N); do
        if [[ -f "$file" ]]; then
            if ! zsh -n "$file" 2>/dev/null; then
                err "Syntax-Fehler in: ${file#$DOTFILES_DIR/}"
                zsh -n "$file" 2>&1 | head -3
                (( errors++ ))
            fi
        fi
    done

    if (( errors > 0 )); then
        err "$errors Datei(en) mit Syntax-Fehlern"
        return 1
    fi

    ok "Shell-Syntax OK"
    return 0
}

# ------------------------------------------------------------
# 2. Dokumentation prÃ¼fen
# ------------------------------------------------------------
check_docs() {
    log "PrÃ¼fe ob Dokumentation aktuell ist..."

    if ! "$DOTFILES_DIR/.github/scripts/generate-docs.sh" --check >/dev/null 2>&1; then
        err "Dokumentation ist veraltet!"
        print ""
        print "  ${C_DIM}Bitte ausfÃ¼hren:${C_RESET}"
        print "    ${C_BOLD}./.github/scripts/generate-docs.sh --generate${C_RESET}"
        print ""
        print "  ${C_DIM}Dann erneut committen.${C_RESET}"
        return 1
    fi

    ok "Dokumentation ist aktuell"
    return 0
}

# ------------------------------------------------------------
# 3. Execute-Berechtigungen prÃ¼fen
# ------------------------------------------------------------
check_executable_permissions() {
    log "PrÃ¼fe Execute-Berechtigungen..."
    local errors=0

    # fzf-Helper mÃ¼ssen ausfÃ¼hrbar sein (auÃŸer config und *.zsh)
    for file in "$DOTFILES_DIR"/terminal/.config/fzf/*(N-.); do
        local name=$(basename "$file")
        # Ãœberspringe config und .zsh Dateien (werden gesourced)
        [[ "$name" == "config" || "$name" == *.zsh ]] && continue

        if [[ ! -x "$file" ]]; then
            err "fzf/$name: Fehlende Execute-Berechtigung"
            err "  â†’ chmod +x $file"
            (( errors++ ))
        fi
    done

    # Haupt-Skripte mÃ¼ssen ausfÃ¼hrbar sein
    for file in "$DOTFILES_DIR"/setup/bootstrap.sh \
                "$DOTFILES_DIR"/.github/scripts/generate-docs.sh \
                "$DOTFILES_DIR"/.github/scripts/health-check.sh; do
        if [[ -f "$file" && ! -x "$file" ]]; then
            err "$(basename $file): Fehlende Execute-Berechtigung"
            (( errors++ ))
        fi
    done

    if (( errors > 0 )); then
        err "$errors Datei(en) ohne Execute-Berechtigung"
        return 1
    fi

    ok "Execute-Berechtigungen OK"
    return 0
}

# ------------------------------------------------------------
# 4. Alias-Datei-Format prÃ¼fen (Guards, Header)
# ------------------------------------------------------------
check_alias_format() {
    log "PrÃ¼fe Alias-Datei-Format..."
    local errors=0

    for file in "$DOTFILES_DIR"/terminal/.config/alias/*.alias(N); do
        local name=$(basename "$file")

        # Header-Block vorhanden?
        if ! head -3 "$file" | grep -q "^# ===="; then
            err "$name: Kein Header-Block"
            (( errors++ ))
        fi

        # Guard-Check vorhanden?
        if ! grep -q "command -v.*>/dev/null" "$file"; then
            err "$name: Kein Guard-Check"
            (( errors++ ))
        fi
    done

    if (( errors > 0 )); then
        err "$errors Alias-Datei(en) mit Format-Fehlern"
        return 1
    fi

    ok "Alias-Format OK"
    return 0
}

# ------------------------------------------------------------
# 5. Header-EinrÃ¼ckungen prÃ¼fen (Feldname auf 12 Zeichen gepaddet)
# ------------------------------------------------------------
check_header_alignment() {
    log "PrÃ¼fe Header-EinrÃ¼ckungen..."
    local errors=0

    # Standard-Felder: Feldname wird auf 12 Zeichen gepaddet, dann " :"
    # Format: "# Feldname   :" (lÃ¤ngstes Feld: Alternativen = 12 Zeichen)
    local -a fields=(
        "Zweck       :"
        "Pfad        :"
        "Docs        :"
        "Config      :"
        "Nutzt       :"
        "Ersetzt     :"
        "Aliase      :"
        "Aufruf      :"
        "Hinweis     :"
        "Verwendung  :"
        "Theme       :"
        "Laden       :"
        "Geladen     :"
        "STEP        :"
        "BenÃ¶tigt    :"
        "Plattform   :"
        "Font        :"
        "Speicherort :"
        "Packages    :"
        "Hooks       :"
        "Cache       :"
        "Aktivierung :"
        "Zielort     :"
        "Profil      :"
        "Alternativen :"
        "Lizenz      :"
        "Generiert   :"
    )

    # Alle Dateien mit Header-BlÃ¶cken prÃ¼fen
    local files=(
        "$DOTFILES_DIR"/terminal/.config/alias/*.alias(N)
        "$DOTFILES_DIR"/terminal/.config/fzf/*(N.)
        "$DOTFILES_DIR"/terminal/.config/zsh/*.zsh(N)
        "$DOTFILES_DIR"/terminal/.config/*/config(N)
        "$DOTFILES_DIR"/terminal/.config/*/*.toml(N)
        "$DOTFILES_DIR"/terminal/.config/*/*.yml(N)
        "$DOTFILES_DIR"/terminal/.config/theme-style(N)
        "$DOTFILES_DIR"/terminal/.config/fd/ignore(N)
        "$DOTFILES_DIR"/terminal/.config/shellcheckrc(N)
        "$DOTFILES_DIR"/terminal/.zsh*(N)
        "$DOTFILES_DIR"/terminal/.zprofile(N)
        "$DOTFILES_DIR"/terminal/.zlogin(N)
        "$DOTFILES_DIR"/setup/*.sh(N)
        "$DOTFILES_DIR"/setup/modules/*.sh(N)
        "$DOTFILES_DIR"/setup/Brewfile(N)
        "$DOTFILES_DIR"/.github/scripts/**/*.sh(N)
    )

    for file in "${files[@]}"; do
        [[ ! -f "$file" ]] && continue
        local relpath="${file#$DOTFILES_DIR/}"

        for field in "${fields[@]}"; do
            local fieldname="${field%% *}"
            # PrÃ¼fe ob Feld existiert aber falsch eingerÃ¼ckt ist
            if grep -q "^# ${fieldname}[[:space:]]*:" "$file" 2>/dev/null; then
                if ! grep -q "^# ${field}" "$file" 2>/dev/null; then
                    err "$relpath: '# ${fieldname}' falsch eingerÃ¼ckt (Standard: '# ${field}')"
                    (( errors++ ))
                fi
            fi
        done
    done

    if (( errors > 0 )); then
        err "$errors Header-Feld(er) mit falscher EinrÃ¼ckung"
        print ""
        print "  ${C_DIM}Standard: Feldname auf 12 Zeichen + ' :'${C_RESET}"
        print "    ${C_BOLD}# Zweck       :${C_RESET}  ${C_DIM}(5 Zeichen + 7 Spaces)${C_RESET}"
        print "    ${C_BOLD}# Alternativen :${C_RESET}  ${C_DIM}(12 Zeichen + 0 Spaces)${C_RESET}"
        return 1
    fi

    ok "Header-EinrÃ¼ckungen OK"
    return 0
}

# ------------------------------------------------------------
# 6. Markdown-Lint prÃ¼fen
# ------------------------------------------------------------
check_markdown() {
    log "PrÃ¼fe Markdown-Dateien..."

    # markdownlint-cli2 verfÃ¼gbar?
    if ! command -v markdownlint-cli2 >/dev/null 2>&1; then
        warn "markdownlint-cli2 nicht gefunden â€“ Ã¼bersprungen"
        warn "Installieren mit: brew install markdownlint-cli2"
        return 0  # Kein Fehler, nur Warnung
    fi

    # Markdownlint ausfÃ¼hren (Ausgabe nur bei Fehlern)
    local output
    output=$(markdownlint-cli2 --config "$DOTFILES_DIR/terminal/.config/markdownlint-cli2/.markdownlint-cli2.jsonc" '**/*.md' '#node_modules' 2>&1)
    local exit_code=$?

    if (( exit_code != 0 )); then
        err "Markdown-Fehler gefunden!"
        # Nur relevante Zeilen anzeigen (keine "Finding:", "Linting:", "Summary:")
        echo "$output" | grep -v "^Finding:" | grep -v "^Linting:" | grep -v "^Summary:" | grep -v "^markdownlint-cli2"
        print ""
        print "  ${C_DIM}Fehler beheben oder Generatoren anpassen:${C_RESET}"
        print "    ${C_BOLD}.github/scripts/generators/*.sh${C_RESET}"
        return 1
    fi

    ok "Markdown OK"
    return 0
}

# ------------------------------------------------------------
# 7. Health-Check ausfÃ¼hren
# ------------------------------------------------------------
check_health() {
    log "FÃ¼hre Health-Check aus..."

    local health_script="$DOTFILES_DIR/.github/scripts/health-check.sh"

    if [[ ! -x "$health_script" ]]; then
        warn "health-check.sh nicht ausfÃ¼hrbar â€“ Ã¼bersprungen"
        return 0
    fi

    # Health-Check ausfÃ¼hren (Ausgabe unterdrÃ¼cken, nur Exit-Code prÃ¼fen)
    if ! "$health_script" >/dev/null 2>&1; then
        err "Health-Check fehlgeschlagen!"
        print ""
        print "  ${C_DIM}Details anzeigen mit:${C_RESET}"
        print "    ${C_BOLD}./.github/scripts/health-check.sh${C_RESET}"
        return 1
    fi

    ok "Health-Check OK"
    return 0
}

# ------------------------------------------------------------
# Hauptprogramm
# ------------------------------------------------------------
print ""
print "${C_OVERLAY0}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${C_RESET}"
print "${C_MAUVE}ðŸ” ${C_BOLD}Pre-Commit Checks${C_RESET}"
print "${C_OVERLAY0}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${C_RESET}"
print ""

failed=0

check_shell_syntax || (( failed++ ))
check_executable_permissions || (( failed++ ))
check_docs || (( failed++ ))
check_alias_format || (( failed++ ))
check_header_alignment || (( failed++ ))
check_markdown || (( failed++ ))
check_health || (( failed++ ))

print ""
print "${C_OVERLAY0}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${C_RESET}"

if (( failed > 0 )); then
    print ""
    err "Pre-Commit fehlgeschlagen (${C_BOLD}$failed${C_RESET}${C_RED} Check(s))"
    print ""
    print "  ${C_RED}${C_BOLD}--no-verify ist VERBOTEN!${C_RESET}"
    print "  ${C_DIM}Bitte Fehler beheben und erneut committen.${C_RESET}"
    exit 1
fi

print ""
ok "Alle Checks bestanden"
exit 0
