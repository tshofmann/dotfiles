#!/usr/bin/env zsh
# ============================================================
# cmds - Helper für cmds() Funktion
# ============================================================
# Zweck       : Liste und Preview für cmds (Alias-Browser) in fzf
# Pfad        : ~/.config/fzf/cmds
# Aufruf      : cmds <list|preview> [args...]
# ============================================================
# Commands:
#   list                   – Listet alle Aliase und Funktionen
#   preview <mode> <sel>   – Generiert Preview (code|tldr)
# ============================================================

# Benötigt für ZSH-Pattern mit # (0+ Zeichen)
setopt extendedglob

# Gemeinsame Bibliothek laden (Farben, ANSI-Strip)
source "${0:A:h}/lib.zsh"

# ------------------------------------------------------------
# Subcommand: list
# ------------------------------------------------------------
# Extrahiert Aliase und Funktionen aus allen .alias-Dateien
# Format: name|typ|kategorie|beschreibung (pipe-separiert)
_cmds_list() {
    local alias_dir="${XDG_CONFIG_HOME:-$HOME/.config}/alias"
    local entries=""
    local file category prev_comment line

    for file in "$alias_dir"/*.alias; do
        [[ -f "$file" ]] || continue
        category="${${file##*/}%.alias}"
        prev_comment=""

        while IFS= read -r line; do
            # Kommentar merken (Zeile beginnt mit # oder eingerückt mit #)
            local trimmed_line="${line#"${line%%[![:space:]]*}"}"
            if [[ "$trimmed_line" == \#* ]]; then
                prev_comment="${trimmed_line#\#}"
                prev_comment="${prev_comment## }"  # Führendes Leerzeichen entfernen
                continue
            fi

            # Alias: "alias name='..." oder 'alias name="...'
            if [[ "$line" == alias\ * ]]; then
                # Extrahiere Namen zwischen "alias " und "="
                local alias_part="${line#alias }"
                local alias_name="${alias_part%%=*}"
                alias_name="${alias_name## }"  # Trim
                alias_name="${alias_name%% }"
                if [[ -n "$alias_name" && "$alias_name" != *" "* ]]; then
                    entries+="${alias_name}|alias|${category}|${prev_comment}"$'\n'
                fi
                prev_comment=""
                continue
            fi

            # Funktion: "name() {" (keine privaten mit _)
            local trimmed="${line#"${line%%[![:space:]]*}"}"
            if [[ "$trimmed" == [a-zA-Z][a-zA-Z0-9_-]#"() {"* && "$trimmed" != _* ]]; then
                local func_name="${trimmed%%\(*}"
                if [[ -n "$func_name" && "$func_name" != *" "* ]]; then
                    entries+="${func_name}|func|${category}|${prev_comment}"$'\n'
                fi
                prev_comment=""
                continue
            fi

            # Andere Zeile = Kommentar zurücksetzen
            prev_comment=""
        done < "$file"
    done

    # Sortieren und Duplikate entfernen
    echo "$entries" | sort -t'|' -k1,1 -u
}

# ------------------------------------------------------------
# Subcommand: preview
# ------------------------------------------------------------
_cmds_preview() {
    local mode="${1:-code}"
    local selection="${2:-}"

    if [[ -z "$selection" ]]; then
        echo "${C_RED}Fehler:${C_RESET} cmds preview benötigt eine Auswahl als zweites Argument." >&2
        return 1
    fi

    # Extrahiere Name und Kategorie aus fzf-Zeile (ANSI-Codes entfernen)
    local line name cat
    line=$(echo "$selection" | _fzf_strip_ansi)
    name=$(echo "$line" | awk '{print $1}')
    cat=$(echo "$line" | awk '{print $3}')

    # Alias-Datei ermitteln
    local alias_dir="${XDG_CONFIG_HOME:-$HOME/.config}/alias"
    local file="${alias_dir}/${cat}.alias"

    case "$mode" in
        code)
            # Code-Definition aus Alias-Datei extrahieren
            if [[ ! -f "$file" ]]; then
                echo "${C_RED}Datei nicht gefunden:${C_RESET} $file"
                return 1
            fi

            # AWK-Skript: Sucht Alias oder Funktion mit vorangehendem Kommentar
            # Hinweis: Funktionsende wird durch } auf gleicher Einrückungsebene wie
            #          die Funktionsdefinition erkannt. Das funktioniert sowohl für
            #          Top-Level-Funktionen als auch für Funktionen innerhalb von
            #          if-Blöcken (z.B. rg-live() in rg.alias).
            local extracted
            extracted=$(awk -v name="$name" '
                BEGIN { found=0; buffer=""; printing=0; indent="" }

                # Kommentar-Zeilen (eingerückt oder nicht) merken
                /^[[:space:]]*#/ {
                    if (!found) buffer = $0 "\n"
                    next
                }

                # Alias-Definition: alias name="..." oder alias name='\''...'\''
                $0 ~ "^alias[[:space:]]+" name "=" {
                    printf "%s%s\n", buffer, $0
                    found=1; buffer=""
                    next
                }

                # Funktions-Definition: name() { (auch eingerückt)
                # Exakter Namensvergleich verhindert false positives (z.B. fa vs fak)
                # Pattern erlaubt auch Bindestriche (z.B. bat-theme)
                /^[[:space:]]*[a-zA-Z_][a-zA-Z0-9_-]*\(\)[[:space:]]*\{/ {
                    match($0, /^[[:space:]]*/)
                    line_indent = substr($0, RSTART, RLENGTH)
                    rest = substr($0, RLENGTH + 1)
                    match(rest, /^[a-zA-Z_][a-zA-Z0-9_-]*/)
                    func_name = substr(rest, RSTART, RLENGTH)
                    if (func_name == name && !found) {
                        printf "%s", buffer
                        found=1; buffer=""
                        printing=1
                        indent = line_indent  # Einrückung merken
                    }
                }

                # Funktionskörper ausgeben
                printing { print }

                # Funktionsende: } auf gleicher Einrückungsebene wie Funktionsstart
                printing && $0 ~ "^" indent "}[[:space:]]*$" { printing=0; exit }

                # Kein Match = Buffer zurücksetzen
                !found { buffer="" }
            ' "$file")

            # Syntax-Highlighting mit bat (falls verfügbar)
            if command -v bat >/dev/null 2>&1; then
                echo "$extracted" | bat --language=zsh --style=plain --color=always
            else
                echo "$extracted"
            fi
            ;;

        tldr)
            # tldr-Seite für die Tool-Kategorie anzeigen
            if command -v tldr >/dev/null 2>&1; then
                tldr --color=always "$cat" 2>/dev/null || echo "Keine tldr-Seite für ${C_MAUVE}${cat}${C_RESET}"
            else
                echo "${C_RED}tldr nicht installiert${C_RESET}"
            fi
            ;;

        *)
            echo "${C_RED}Unbekannter Modus:${C_RESET} $mode"
            echo "Verfügbar: code, tldr"
            return 1
            ;;
    esac
}

# ------------------------------------------------------------
# Usage
# ------------------------------------------------------------
_cmds_usage() {
    cat <<EOF
Usage: cmds <command> [args...]

Commands:
  list                        Liste aller Aliase und Funktionen
  preview <mode> <selection>  Generiere Preview für Auswahl
                              Modes: code, tldr

EOF
}

# ------------------------------------------------------------
# Main Dispatch
# ------------------------------------------------------------
_fzf_dispatch "cmds" "$@"
