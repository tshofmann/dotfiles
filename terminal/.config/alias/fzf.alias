# ============================================================
# fzf.alias - Generische fzf-Funktionen
# ============================================================
# Zweck   : Tool-unspezifische fzf-Utilities
# Pfad    : ~/.config/alias/fzf.alias
# Docs    : https://github.com/junegunn/fzf
# ============================================================
# Hinweis : Shell-Keybindings via Ctrl+X Prefix (in init.zsh):
#           Ctrl+X 1=History, Ctrl+X 2=Dateisuche, Ctrl+X 3=Verzeichnis
#
#           Globale fzf-Optionen in ~/.config/fzf/config
#
#           Tool-spezifische fzf-Funktionen:
#           - fd.alias   → cdf (Verzeichnis), fo (Datei öffnen)
#           - rg.alias   → rgf (Live-Grep)
#           - git.alias  → glog, gbr, gst, gstash
#           - brew.alias → bip, brp
#           - gh.alias   → ghpr, ghis, ghrun, ghrepo, ghgist
# ============================================================

# Guard   : Nur wenn fzf installiert ist
if ! command -v fzf >/dev/null 2>&1; then
    return 0
fi

# ------------------------------------------------------------
# Shell-Keybindings (in init.zsh konfiguriert, Ctrl+X Prefix)
# ------------------------------------------------------------
# Ctrl+X 1: History durchsuchen mit Vorschau
# Ctrl+X 2: Datei suchen mit bat-Vorschau, Pfad einfügen
# Ctrl+X 3: Verzeichnis wechseln mit eza-Vorschau

# ------------------------------------------------------------
# ZOXIDE + FZF: Intelligente Directory-Jumps
# ------------------------------------------------------------
# zi ist bereits in zoxide eingebaut (zi = zoxide interactive)
# Erweiterte Version mit Score-Anzeige, Lösch- und Kopier-Option
# Community-Pattern: -n2.. für Pfade mit Leerzeichen
if command -v zoxide >/dev/null 2>&1; then
    # zoxide + fzf mit eza-Vorschau – Enter=Wechseln, Ctrl+D=Löschen, Ctrl+Y=Kopieren
    zf() {
        local selection dir
        local preview_cmd="eza --tree --level=2 --icons --color=always {2..} 2>/dev/null || ls -la {2..}"
        
        # Mit Score anzeigen (Format: "1234.5 /path/to/dir")
        # -n2.. durchsucht nur den Pfad (nicht den Score), unterstützt Leerzeichen
        selection=$(zoxide query -l -s | \
            fzf -n2.. \
                --preview "$preview_cmd" \
                --bind 'ctrl-d:execute-silent(zoxide remove {2..})+reload(zoxide query -l -s)' \
                --bind 'ctrl-y:execute-silent(echo -n {2..} | pbcopy)' \
                --header='Enter: Wechseln | Ctrl+D: Eintrag löschen | Ctrl+Y: Pfad kopieren')
        
        # Pfad extrahieren (alles nach dem Score)
        [[ -n "$selection" ]] && dir="${selection#* }" && cd "$dir"
    }
fi

# ------------------------------------------------------------
# KILL + FZF: Prozess-Management
# ------------------------------------------------------------
# Prozesse interaktiv suchen und beenden (Tab für Mehrfachauswahl)
# Prozesse beenden – Enter=Beenden, Tab=Mehrfach, Ctrl+S=Apps/Alle
fkill() {
    local pid
    local helper="${XDG_CONFIG_HOME:-$HOME/.config}/fzf/fkill-list"
    
    pid=$("$helper" apps | \
        fzf -m \
            --freeze-left=1 \
            --prompt='Apps> ' \
            --header='Enter: Beenden | Tab: Mehrfach | Ctrl+S: Apps/Alle' \
            --bind "ctrl-s:transform:[[ \$FZF_PROMPT == 'Apps> ' ]] && echo 'reload($helper all)+change-prompt(Alle> )' || echo 'reload($helper apps)+change-prompt(Apps> )'" | \
        awk '{print $1}')
    
    [[ -n "$pid" ]] && echo "$pid" | xargs kill -${1:-15}
}

# ------------------------------------------------------------
# MAN + FZF + BAT: Man-Pages Browser
# ------------------------------------------------------------
# Man-Pages interaktiv durchsuchen mit Syntax-Highlighting
# Man-Pages mit bat-Vorschau – Enter=Öffnen, Ctrl+S=man↔tldr
fman() {
    local selection page section
    local helper="${XDG_CONFIG_HOME:-$HOME/.config}/fzf/fman-preview"
    
    selection=$(man -k . 2>/dev/null | \
        fzf --prompt='man> ' \
            --preview "[[ \$FZF_PROMPT == 'tldr> ' ]] && $helper tldr {} || $helper man {}" \
            --header='Enter: man öffnen | Ctrl+S: man ↔ tldr' \
            --bind "ctrl-s:transform:[[ \$FZF_PROMPT == 'man> ' ]] && echo 'change-prompt(tldr> )+refresh-preview' || echo 'change-prompt(man> )+refresh-preview'")
    
    if [[ -n "$selection" ]]; then
        page=$(echo "$selection" | sed 's/(.*//' | xargs)
        section=$(echo "$selection" | sed -n 's/.*([^0-9]*\([0-9][a-z]*\)).*/\1/p')
        if [[ -n "$section" ]]; then
            man "$section" "$page"
        else
            man "$page"
        fi
    fi
}

# ------------------------------------------------------------
# ALIAS + FZF: Alias-/Funktions-Browser
# ------------------------------------------------------------
# Fuzzy-Suche für Aliase/Funktionen – Enter=Übernehmen, Ctrl+S=tldr↔Code
fa() {
    local alias_dir="${XDG_CONFIG_HOME:-$HOME/.config}/alias"
    local fzf_dir="${XDG_CONFIG_HOME:-$HOME/.config}/fzf"
    local query="${1:-}"
    local selection name entries
    local file category prev_comment line
    local strip_ansi="sed 's/\x1b\[[0-9;]*m//g'"
    
    # Aliase und Funktionen aus allen .alias-Dateien extrahieren
    # Format: name|typ|kategorie|beschreibung
    entries=""
    for file in "$alias_dir"/*.alias; do
        [[ -f "$file" ]] || continue
        category="${${file##*/}%.alias}"
        prev_comment=""
        
        while IFS= read -r line; do
            # Kommentar merken (Zeile beginnt mit # oder eingerückt mit #)
            local trimmed_line="${line#"${line%%[![:space:]]*}"}"
            if [[ "$trimmed_line" == \#* ]]; then
                prev_comment="${trimmed_line#\#}"
                prev_comment="${prev_comment## }"  # Führendes Leerzeichen entfernen
                continue
            fi
            
            # Alias: "alias name='..." oder 'alias name="...'
            if [[ "$line" == alias\ * ]]; then
                # Extrahiere Namen zwischen "alias " und "="
                local alias_part="${line#alias }"
                local alias_name="${alias_part%%=*}"
                alias_name="${alias_name## }"  # Trim
                alias_name="${alias_name%% }"
                if [[ -n "$alias_name" && "$alias_name" != *" "* ]]; then
                    entries+="${alias_name}|alias|${category}|${prev_comment}"$'\n'
                fi
                prev_comment=""
                continue
            fi
            
            # Funktion: "name() {" (keine privaten mit _)
            # Erst trimmen, dann Pattern prüfen (ohne EXTENDED_GLOB)
            local trimmed="${line#"${line%%[![:space:]]*}"}"
            if [[ "$trimmed" == [a-zA-Z]*"() {"* && "$trimmed" != _* ]]; then
                local func_name="${trimmed%%\(*}"        # Ab ( abschneiden
                if [[ -n "$func_name" && "$func_name" != *" "* ]]; then
                    entries+="${func_name}|func|${category}|${prev_comment}"$'\n'
                fi
                prev_comment=""
                continue
            fi
            
            # Andere Zeile = Kommentar zurücksetzen
            prev_comment=""
        done < "$file"
    done
    
    # Sortieren und Duplikate entfernen
    entries=$(echo "$entries" | sort -t'|' -k1,1 -u)
    
    # Formatierte Ausgabe für fzf (Farben aus shell-colors)
    # Preview prüft Prompt für Toggle (wie fman-Pattern)
    selection=$(echo "$entries" | awk -F'|' \
        -v mauve="$C_MAUVE" -v green="$C_GREEN" -v blue="$C_BLUE" \
        -v text="$C_TEXT" -v reset="$C_RESET" '
        NF >= 3 {
            name = $1
            typ = ($2 == "alias") ? "alias" : "func "
            cat = $3
            desc = $4
            typcolor = ($2 == "alias") ? green : blue
            printf "%s%-12s%s %s%-5s%s %s%-10s%s %s%s%s\n", 
                mauve, name, reset,
                typcolor, typ, reset,
                text, cat, reset,
                text, desc, reset
        }
    ' | fzf --ansi --query="$query" \
        --prompt='tldr> ' \
        --header='Enter: Befehl übernehmen | Ctrl+S: tldr ↔ Code' \
        --preview "[[ \$FZF_PROMPT == 'code> ' ]] && zsh '$fzf_dir/fa-preview' code {} || zsh '$fzf_dir/fa-preview' tldr {}" \
        --preview-window='right:50%:wrap' \
        --bind "ctrl-s:transform:[[ \$FZF_PROMPT == 'tldr> ' ]] && echo 'change-prompt(code> )+refresh-preview' || echo 'change-prompt(tldr> )+refresh-preview'")
    
    # Bei Enter: Befehl ins Edit-Buffer (kann editiert/ausgeführt werden)
    if [[ -n "$selection" ]]; then
        name=$(echo "$selection" | eval "$strip_ansi" | awk '{print $1}')
        print -z "$name"
    fi
}

# ------------------------------------------------------------
# ENV + FZF: Umgebungsvariablen-Browser
# ------------------------------------------------------------
# Umgebungsvariablen durchsuchen mit formatierter Anzeige
# Umgebungsvariablen mit Farbkodierung – Enter=Export→Edit, Ctrl+Y=Kopieren
fenv() {
    local selection name value
    
    # Farbkodiert KEY=VALUE-Zeilen nach Kategorie (Catppuccin Mocha)
    # Dotfiles/XDG=Mauve, PATH=Green, Tools=Blue, Rest=Text
    _fenv_colorize() {
        awk -F= -v mauve="$C_MAUVE" -v green="$C_GREEN" -v blue="$C_BLUE" \
            -v text="$C_TEXT" -v reset="$C_RESET" '{
            name = $1
            value = substr($0, length($1) + 2)
            gsub(/\n/, " ", value)
            
            # Farbauswahl nach Kategorie
            if (name ~ /^(DOTFILES|XDG|CONFIG)/) {
                color = mauve  # Dotfiles-Variablen
            } else if (name ~ /PATH|DIRS/) {
                color = green  # PATH-artige Variablen
            } else if (name ~ /^(FZF|BAT|EZA|RG|FD)/) {
                color = blue   # Tool-Variablen
            } else {
                color = text   # Andere
            }
            
            if (length(value) > 45) {
                value = substr(value, 1, 42) "..."
            }
            printf "%s%-28s%s │ %s%s%s\n", color, name, reset, text, value, reset
        }'
    }
    
    selection=$(printenv | grep -E '^[a-zA-Z_][a-zA-Z0-9_]*=' | sort | _fenv_colorize | fzf --ansi \
        --header='Enter: Export → Edit | Ctrl+Y: Wert kopieren' \
        --preview='n=$(echo {} | cut -d"│" -f1 | xargs)
            v=$(printenv "$n" 2>/dev/null)
            printf "%s%s%s\n\n" "$C_MAUVE" "$n" "$C_RESET"
            if [[ "$v" == *:* ]] && [[ "$n" == *PATH* || "$n" == *DIRS* ]]; then
                echo "$v" | tr ":" "\n" | nl -ba
            else
                echo "$v"
            fi' \
        --preview-window='right:50%,wrap' \
        --bind='ctrl-y:execute-silent(n=$(echo {} | cut -d"│" -f1 | xargs); printenv "$n" | pbcopy)+abort')
    
    if [[ -n "$selection" ]]; then
        name=$(echo "$selection" | cut -d'│' -f1 | xargs)
        value=$(printenv "$name")
        # Export-Statement ins Edit-Buffer (editierbar vor Ausführung)
        print -z "export ${name}=\"${value}\""
    fi
}

