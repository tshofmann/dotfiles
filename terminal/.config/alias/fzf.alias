# ============================================================
# fzf.alias - Generische fzf-Funktionen
# ============================================================
# Zweck       : Tool-unspezifische fzf-Utilities
# Pfad        : ~/.config/alias/fzf.alias
# Docs        : https://github.com/junegunn/fzf
# Config      : ~/.config/fzf/config
# Nutzt       : bat (Code), eza (Verzeichnis), fd (Default-Command), tldr (fman)
# Nutzt       : pdftotext (PDF), 7zz (Archive), identify (Bilder), ffprobe (Video/Audio)
# ============================================================
# Tool-spezifische Funktionen in fd/rg/git/brew/gh.alias.
#
# Helper-Skripte in ~/.config/fzf/:
#   config    – Globale fzf-Optionen (Farben, Layout, Keybindings)
#   init.zsh  – Shell-Integration (Ctrl+X Keybindings, FZF_DEFAULT_COMMAND)
#   lib.zsh   – Shared Utilities (Farben, ANSI-Strip)
#   preview   – Vorschau (file|dir) mit bat/eza
#   action    – Sichere Aktionen (copy, edit, open, git-*, zoxide-*)
#   fman      – Helper für help() (list|preview|toggle)
#   fkill     – Helper für procs() (list)
#   fa        – Helper für cmds() (preview)
# Aliase      : procs, help, cmds, vars
# ============================================================

# Guard   : Nur wenn fzf installiert ist
if ! command -v fzf >/dev/null 2>&1; then
    return 0
fi

# ------------------------------------------------------------
# Shell-Keybindings (in init.zsh konfiguriert, Ctrl+X Prefix)
# ------------------------------------------------------------
# Ctrl+X 1: History durchsuchen mit Vorschau
# Ctrl+X 2: Datei suchen mit bat-Vorschau, Pfad einfügen
# Ctrl+X 3: Verzeichnis wechseln mit eza-Vorschau

# ------------------------------------------------------------
# KILL + FZF: Prozess-Management
# ------------------------------------------------------------
# Prozesse interaktiv suchen und beenden (Tab für Mehrfachauswahl)
# Prozess Browser(signal=15) – Enter=Beenden, Tab=Mehrfach, Ctrl+S=Apps↔Alle
procs() {
    local pid
    local helper="${XDG_CONFIG_HOME:-$HOME/.config}/fzf"

    pid=$("$helper/fkill" list apps | \
        fzf -m \
            --freeze-left=1 \
            --prompt='Apps> ' \
            --header='Enter: Beenden | Tab: Mehrfach | Ctrl+S: Apps/Alle' \
            --bind "ctrl-s:transform:[[ \$FZF_PROMPT == 'Apps> ' ]] && echo 'reload($helper/fkill list all)+change-prompt(Alle> )' || echo 'reload($helper/fkill list apps)+change-prompt(Apps> )'" | \
        awk '{print $1}')

    [[ -n "$pid" ]] && echo "$pid" | xargs kill -${1:-15}
}

# ------------------------------------------------------------
# MAN + FZF + BAT: Man-Pages Browser
# ------------------------------------------------------------
# Man-Pages interaktiv durchsuchen mit Syntax-Highlighting
# Man/tldr Browser – Ctrl+S=Modus wechseln (Liste + Preview), Enter=öffnen
help() {
    local output mode selection page section
    local fzf_dir="${XDG_CONFIG_HOME:-$HOME/.config}/fzf"

    # Ctrl+S wechselt sowohl Liste als auch Preview zwischen man und tldr
    output=$("$fzf_dir/fman" list man | \
        fzf --prompt='man> ' \
            --preview="$fzf_dir/fman preview man {}" \
            --header='Enter: öffnen | Ctrl+S: man ↔ tldr' \
            --bind="ctrl-s:transform:$fzf_dir/fman toggle" \
            --bind="enter:transform:[[ \$FZF_PROMPT == 'tldr> ' ]] && echo 'print(tldr)+accept' || echo 'print(man)+accept'")

    [[ -z "$output" ]] && return 0

    mode=$(echo "$output" | head -1)
    selection=$(echo "$output" | tail -1)
    page=$(echo "$selection" | sed 's/(.*//' | xargs)

    if [[ "$mode" == "tldr" ]]; then
        tldr "$page"
    else
        section=$(echo "$selection" | sed -n 's/.*([^0-9]*\([0-9][a-z]*\)).*/\1/p')
        if [[ -n "$section" ]]; then
            man "$section" "$page"
        else
            man "$page"
        fi
    fi
}

# ------------------------------------------------------------
# ALIAS + FZF: Alias-/Funktions-Browser
# ------------------------------------------------------------
# Fuzzy-Suche für Aliase und Funktionen aus allen .alias-Dateien
# Befehl Browser(suche?) – Enter=Übernehmen, Ctrl+S=tldr↔Code
cmds() {
    local alias_dir="${XDG_CONFIG_HOME:-$HOME/.config}/alias"
    local fzf_dir="${XDG_CONFIG_HOME:-$HOME/.config}/fzf"
    local query="${1:-}"
    local selection name entries
    local file category prev_comment line
    local strip_ansi="sed 's/\x1b\[[0-9;]*m//g'"

    # Aliase und Funktionen aus allen .alias-Dateien extrahieren
    # Format: name|typ|kategorie|beschreibung
    entries=""
    for file in "$alias_dir"/*.alias; do
        [[ -f "$file" ]] || continue
        category="${${file##*/}%.alias}"
        prev_comment=""

        while IFS= read -r line; do
            # Kommentar merken (Zeile beginnt mit # oder eingerückt mit #)
            local trimmed_line="${line#"${line%%[![:space:]]*}"}"
            if [[ "$trimmed_line" == \#* ]]; then
                prev_comment="${trimmed_line#\#}"
                prev_comment="${prev_comment## }"  # Führendes Leerzeichen entfernen
                continue
            fi

            # Alias: "alias name='..." oder 'alias name="...'
            if [[ "$line" == alias\ * ]]; then
                # Extrahiere Namen zwischen "alias " und "="
                local alias_part="${line#alias }"
                local alias_name="${alias_part%%=*}"
                alias_name="${alias_name## }"  # Trim
                alias_name="${alias_name%% }"
                if [[ -n "$alias_name" && "$alias_name" != *" "* ]]; then
                    entries+="${alias_name}|alias|${category}|${prev_comment}"$'\n'
                fi
                prev_comment=""
                continue
            fi

            # Funktion: "name() {" (keine privaten mit _)
            # Erst trimmen, dann Pattern prüfen (ohne EXTENDED_GLOB)
            local trimmed="${line#"${line%%[![:space:]]*}"}"
            if [[ "$trimmed" == [a-zA-Z]*"() {"* && "$trimmed" != _* ]]; then
                local func_name="${trimmed%%\(*}"        # Ab ( abschneiden
                if [[ -n "$func_name" && "$func_name" != *" "* ]]; then
                    entries+="${func_name}|func|${category}|${prev_comment}"$'\n'
                fi
                prev_comment=""
                continue
            fi

            # Andere Zeile = Kommentar zurücksetzen
            prev_comment=""
        done < "$file"
    done

    # Sortieren und Duplikate entfernen
    entries=$(echo "$entries" | sort -t'|' -k1,1 -u)

    # Formatierte Ausgabe für fzf (Farben aus theme-style)
    # Preview prüft Prompt für Toggle (wie fman-Pattern)
    selection=$(echo "$entries" | awk -F'|' \
        -v mauve="$C_MAUVE" -v green="$C_GREEN" -v blue="$C_BLUE" \
        -v text="$C_TEXT" -v reset="$C_RESET" '
        NF >= 3 {
            name = $1
            typ = ($2 == "alias") ? "alias" : "func "
            cat = $3
            desc = $4
            typcolor = ($2 == "alias") ? green : blue
            printf "%s%-12s%s %s%-5s%s %s%-10s%s %s%s%s\n",
                mauve, name, reset,
                typcolor, typ, reset,
                text, cat, reset,
                text, desc, reset
        }
    ' | fzf --ansi --query="$query" \
        --prompt='tldr> ' \
        --header='Enter: Befehl übernehmen | Ctrl+S: tldr ↔ Code' \
        --preview "[[ \$FZF_PROMPT == 'code> ' ]] && zsh '$fzf_dir/fa' preview code {} || zsh '$fzf_dir/fa' preview tldr {}" \
        --preview-window='right:50%:wrap' \
        --bind "ctrl-s:transform:[[ \$FZF_PROMPT == 'tldr> ' ]] && echo 'change-prompt(code> )+refresh-preview' || echo 'change-prompt(tldr> )+refresh-preview'")

    # Bei Enter: Befehl ins Edit-Buffer (kann editiert/ausgeführt werden)
    if [[ -n "$selection" ]]; then
        name=$(echo "$selection" | eval "$strip_ansi" | awk '{print $1}')
        print -z "$name"
    fi
}

# ------------------------------------------------------------
# ENV + FZF: Umgebungsvariablen-Browser
# ------------------------------------------------------------
# Umgebungsvariablen durchsuchen mit formatierter Anzeige
# Variablen Browser – Enter=Export→Edit, Ctrl+Y=Kopieren
vars() {
    local selection name value

    # Farbkodiert KEY=VALUE-Zeilen nach Kategorie (Catppuccin Mocha)
    # Dotfiles/XDG=Mauve, PATH=Green, Tools=Blue, Rest=Text
    _fenv_colorize() {
        awk -F= -v mauve="$C_MAUVE" -v green="$C_GREEN" -v blue="$C_BLUE" \
            -v text="$C_TEXT" -v reset="$C_RESET" '{
            name = $1
            value = substr($0, length($1) + 2)
            gsub(/\n/, " ", value)

            # Farbauswahl nach Kategorie
            if (name ~ /^(DOTFILES|XDG|CONFIG)/) {
                color = mauve  # Dotfiles-Variablen
            } else if (name ~ /PATH|DIRS/) {
                color = green  # PATH-artige Variablen
            } else if (name ~ /^(FZF|BAT|EZA|RG|FD)/) {
                color = blue   # Tool-Variablen
            } else {
                color = text   # Andere
            }

            if (length(value) > 45) {
                value = substr(value, 1, 42) "..."
            }
            printf "%s%-28s%s │ %s%s%s\n", color, name, reset, text, value, reset
        }'
    }

    selection=$(printenv | grep -E '^[a-zA-Z_][a-zA-Z0-9_]*=' | sort | _fenv_colorize | fzf --ansi \
        --header='Enter: Export → Edit | Ctrl+Y: Wert kopieren' \
        --preview='n=$(echo {} | cut -d"│" -f1 | xargs)
            v=$(printenv "$n" 2>/dev/null)
            printf "%s%s%s\n\n" "$C_MAUVE" "$n" "$C_RESET"
            if [[ "$v" == *:* ]] && [[ "$n" == *PATH* || "$n" == *DIRS* ]]; then
                echo "$v" | tr ":" "\n" | nl -ba
            else
                echo "$v"
            fi' \
        --preview-window='right:50%,wrap' \
        --bind='ctrl-y:execute-silent(n=$(echo {} | cut -d"│" -f1 | xargs); printenv "$n" | pbcopy)+abort')

    if [[ -n "$selection" ]]; then
        name=$(echo "$selection" | cut -d'│' -f1 | xargs)
        value=$(printenv "$name")
        # Export-Statement ins Edit-Buffer (editierbar vor Ausführung)
        print -z "export ${name}=\"${value}\""
    fi
}
