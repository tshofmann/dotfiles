# ============================================================
# help.alias - Interaktives Help-System f√ºr dotfiles
# ============================================================
# Zweck   : Zeigt Aliase, Funktionen und Tool-Informationen
# Pfad    : ~/.config/alias/help.alias
# Nutzung : help [command] [args]
# ============================================================

# ------------------------------------------------------------
# Parser-Hilfsfunktionen
# ------------------------------------------------------------

# Shared patterns for section header filtering
typeset -g _HELP_SECTION_HEADERS='Zweck|Pfad|Docs|Hinweis|Guard|Basis|Essenzielle|Erweiterte|Interaktive|Update|Baumansicht|Mit Git|Dateiansicht|Dateityp|Mac App|Voraussetzung|------------'

# Check if a line should be skipped (empty, header dividers)
_help_should_skip_line() {
    local line="$1"
    [[ -z "$line" || "$line" =~ ^#\ =+ || "$line" =~ ^#\ -+ ]]
}

# Check if line starts an EARLY EXIT guard clause
_help_is_early_exit_guard() {
    local line="$1"
    [[ "$line" =~ ^if\ !\ command\ -v ]]
}

# Check if line ends a guard clause
_help_is_guard_end() {
    local line="$1"
    [[ "$line" == "fi" || "$line" =~ ^[[:space:]]*fi[[:space:]]*$ ]]
}

# Check if line is a return statement in guard
_help_is_guard_return() {
    local line="$1"
    [[ "$line" =~ ^[[:space:]]*return\ 0 ]]
}

# Check if line is a function definition
_help_is_function_def() {
    local line="$1"
    [[ "$line" =~ "^[[:space:]]*[a-zA-Z_][a-zA-Z0-9_]*\(\)" ]] && [[ ! "$line" =~ alias ]]
}

# Count net brace change in a line
_help_count_braces() {
    local line="$1"
    local opens="${line//[^\{]/}"
    local closes="${line//[^\}]/}"
    REPLY=$(( ${#opens} - ${#closes} ))
}

# Check if comment is a section header
_help_is_section_header() {
    local comment="$1"
    [[ "$comment" =~ ^($_HELP_SECTION_HEADERS) ]] || \
    [[ "$comment" =~ ^[[:space:]]{3,} ]] || \
    [[ "$comment" =~ \.alias\ -\  ]]
}

# Parse alias file and extract aliases with descriptions
# Format: name|command|description
_help_parse_aliases() {
    setopt local_options extended_glob
    local file="$1"
    [[ -f "$file" ]] || return 1

    local prev_comment="" brace_depth=0 in_guard_if=0

    while IFS= read -r line; do
        _help_should_skip_line "$line" && continue
        if _help_is_early_exit_guard "$line"; then in_guard_if=1; continue; fi
        _help_is_guard_return "$line" && continue
        if [[ $in_guard_if -eq 1 ]] && _help_is_guard_end "$line"; then in_guard_if=0; continue; fi
        if _help_is_function_def "$line"; then
            _help_count_braces "$line"; ((brace_depth += REPLY)); prev_comment=""; continue
        fi
        if [[ $brace_depth -gt 0 ]]; then
            _help_count_braces "$line"; ((brace_depth += REPLY)); continue
        fi
        if [[ "$line" =~ ^[[:space:]]*#\ ([^=].+)$ ]]; then
            local comment="${match[1]}"
            ! _help_is_section_header "$comment" && prev_comment="$comment"
        elif [[ "$line" =~ ^[[:space:]]*alias\ +([^=]+)=(.+)$ ]]; then
            local name="${match[1]}" cmd="${match[2]}"
            cmd="${cmd#[\'\"]}" cmd="${cmd%[\'\"]}"
            echo "$name|$cmd|${prev_comment:-}"; prev_comment=""
        else
            [[ ! "$line" =~ ^# ]] && prev_comment=""
        fi
    done < "$file"
}

# Parse alias file and extract function definitions
# Format: name|description
_help_parse_functions() {
    setopt local_options extended_glob
    local file="$1"
    [[ -f "$file" ]] || return 1

    local prev_comment="" in_guard_if=0 brace_depth=0

    while IFS= read -r line; do
        _help_should_skip_line "$line" && continue
        if _help_is_early_exit_guard "$line"; then in_guard_if=1; continue; fi
        _help_is_guard_return "$line" && continue
        if [[ $in_guard_if -eq 1 ]] && _help_is_guard_end "$line"; then in_guard_if=0; continue; fi
        if [[ $brace_depth -gt 0 ]]; then
            _help_count_braces "$line"; ((brace_depth += REPLY)); continue
        fi
        if [[ "$line" =~ ^[[:space:]]*#\ ([^=].+)$ ]]; then
            local comment="${match[1]}"
            ! _help_is_section_header "$comment" && prev_comment="$comment"
        elif _help_is_function_def "$line"; then
            local name=""
            [[ "$line" =~ "^[[:space:]]*([a-zA-Z_][a-zA-Z0-9_]*)\(\)" ]] && name="${match[1]}"
            [[ -n "$prev_comment" && -n "$name" ]] && echo "$name|$prev_comment"
            prev_comment=""
            _help_count_braces "$line"; ((brace_depth += REPLY))
        else
            [[ ! "$line" =~ ^# ]] && prev_comment=""
        fi
    done < "$file"
}

# Get category name from alias file
_help_get_category() {
    local file="$1"
    echo "${file:t:r}"
}

# Get category description from alias file header
_help_get_category_description() {
    local file="$1"
    [[ -f "$file" ]] || return 1
    local desc=$(grep -m1 "^# Zweck" "$file" | sed 's/^# Zweck[[:space:]]*:[[:space:]]*//')
    [[ -n "$desc" ]] && echo "$desc" || echo ""
}

# Get documentation URL from alias file header
_help_get_docs_url() {
    local file="$1"
    [[ -f "$file" ]] || return 1
    local url=$(grep -m1 "^# Docs" "$file" | sed 's/^# Docs[[:space:]]*:[[:space:]]*//')
    [[ -n "$url" ]] && echo "$url" || echo ""
}

# Check if a tool is installed and get its version
_help_get_tool_version() {
    local tool="$1"
    if ! command -v "$tool" >/dev/null 2>&1; then echo "not_installed"; return 1; fi
    local version=""
    case "$tool" in
        eza) version=$("$tool" --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1) ;;
        bat|fd|fzf|rg|starship|zoxide|gh|btop) version=$("$tool" --version 2>/dev/null | head -1 | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1) ;;
        mas) version=$(mas version 2>/dev/null) ;;
        *) version=$("$tool" --version 2>/dev/null | head -1 | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1) ;;
    esac
    [[ -n "$version" ]] && echo "$version" || echo "unknown"
}

# ------------------------------------------------------------
# Farben (Catppuccin Mocha - True Color 24-bit)
# ------------------------------------------------------------
typeset -g _HELP_COLOR_RESET=$'\e[0m'
typeset -g _HELP_COLOR_HEADER=$'\e[1;38;2;203;166;247m'  # Mauve (bold)
typeset -g _HELP_COLOR_CATEGORY=$'\e[38;2;137;220;235m'  # Sky
typeset -g _HELP_COLOR_ALIAS=$'\e[38;2;249;226;175m'     # Yellow
typeset -g _HELP_COLOR_COMMAND=$'\e[38;2;166;227;161m'   # Green
typeset -g _HELP_COLOR_DESC=$'\e[38;2;166;173;200m'      # Subtext 0
typeset -g _HELP_COLOR_SUCCESS=$'\e[38;2;166;227;161m'   # Green
typeset -g _HELP_COLOR_ERROR=$'\e[38;2;243;139;168m'     # Red
typeset -g _HELP_COLOR_ICON=$'\e[38;2;137;180;250m'      # Blue

# Print colored header box
# Note: Emojis take 2 terminal columns but zsh ${#var} counts them as 1
# We need to reduce padding by 1 for each emoji
_help_print_header() {
    local title="$1"
    local inner_width=63

    # Count wide characters (emojis): byte length vs zsh char count difference
    # Each emoji is 4 bytes but zsh counts it as 1 char, displays as 2 cols
    local char_len=${#title}
    local byte_len=$(printf '%s' "$title" | wc -c | tr -d ' ')
    # Each emoji adds 3 extra bytes (4 bytes - 1 char count)
    local emoji_count=$(( (byte_len - char_len) / 3 ))

    # Calculate padding: inner_width - display_width of title
    # display_width = char_len + emoji_count (each emoji adds 1 extra column)
    local display_width=$((char_len + emoji_count))
    local padding=$((inner_width - display_width))
    local spaces=$(printf '%*s' "$padding" '')

    # Build border line
    local border=$(printf '‚îÄ%.0s' {1..$inner_width})

    print "${_HELP_COLOR_HEADER}‚ï≠‚îÄ${border}‚îÄ‚ïÆ${_HELP_COLOR_RESET}"
    print "${_HELP_COLOR_HEADER}‚îÇ${_HELP_COLOR_RESET} ${title}${spaces} ${_HELP_COLOR_HEADER}‚îÇ${_HELP_COLOR_RESET}"
    print "${_HELP_COLOR_HEADER}‚ï∞‚îÄ${border}‚îÄ‚ïØ${_HELP_COLOR_RESET}"
}

# Show overview of all categories
_help_overview() {
    _help_print_header "üìñ help"
    echo ""
    echo "${_HELP_COLOR_HEADER}NAME${_HELP_COLOR_RESET}"
    echo "       help - Zeigt Aliase, Funktionen und Tool-Informationen"
    echo ""
    echo "${_HELP_COLOR_HEADER}SYNOPSIS${_HELP_COLOR_RESET}"
    echo "       ${_HELP_COLOR_COMMAND}help${_HELP_COLOR_RESET} [KATEGORIE]"
    echo "       ${_HELP_COLOR_COMMAND}help search${_HELP_COLOR_RESET} <text>"
    echo "       ${_HELP_COLOR_COMMAND}help tools${_HELP_COLOR_RESET} | ${_HELP_COLOR_COMMAND}help --fzf${_HELP_COLOR_RESET}"
    echo ""
    echo "${_HELP_COLOR_HEADER}KATEGORIEN${_HELP_COLOR_RESET}"

    local alias_dir="${HOME}/.config/alias"
    if [[ -d "$alias_dir" ]]; then
        local -a categories=()
        for file in "$alias_dir"/*.alias(N); do
            local category=$(_help_get_category "$file")
            local desc=$(_help_get_category_description "$file")
            categories+=("$category|$desc")
        done
        for entry in ${(o)categories}; do
            local category="${entry%%|*}"
            local desc="${entry#*|}"
            printf "       ${_HELP_COLOR_ALIAS}%-12s${_HELP_COLOR_RESET} %s\n" "$category" "$desc"
        done
    fi

    echo ""
    echo "${_HELP_COLOR_HEADER}BEISPIELE${_HELP_COLOR_RESET}"
    echo "       ${_HELP_COLOR_COMMAND}help git${_HELP_COLOR_RESET}            Zeige Git-Aliase"
    echo "       ${_HELP_COLOR_COMMAND}help search commit${_HELP_COLOR_RESET}  Suche nach 'commit'"
    echo ""
}

# Show aliases for a specific category
_help_category() {
    local category="$1"
    local alias_file="${HOME}/.config/alias/${category}.alias"

    if [[ ! -f "$alias_file" ]]; then
        echo "${_HELP_COLOR_ERROR}‚úñ Kategorie nicht gefunden: $category${_HELP_COLOR_RESET}"
        echo ""
        echo "Verf√ºgbare Kategorien:"
        local alias_dir="${HOME}/.config/alias"
        for file in "$alias_dir"/*.alias(N); do
            echo "  - $(_help_get_category "$file")"
        done | sort
        return 1
    fi

    _help_print_header "üìÅ $category"
    echo ""

    # Get description
    local desc=$(_help_get_category_description "$alias_file")
    echo "${_HELP_COLOR_HEADER}NAME${_HELP_COLOR_RESET}"
    echo "       $category - $desc"
    echo ""

    # Parse and display aliases
    local has_aliases=0
    local alias_output=""
    while IFS='|' read -r name cmd adesc; do
        has_aliases=1
        alias_output+=$(printf "       ${_HELP_COLOR_ALIAS}%-8s${_HELP_COLOR_RESET} ${_HELP_COLOR_COMMAND}%s${_HELP_COLOR_RESET}\n" "$name" "$cmd")
        alias_output+=$'\n'
    done < <(_help_parse_aliases "$alias_file")

    if [[ $has_aliases -eq 1 ]]; then
        echo "${_HELP_COLOR_HEADER}ALIASE${_HELP_COLOR_RESET}"
        printf "%s" "$alias_output"
    fi

    # Parse and display functions
    local has_functions=0
    local func_output=""
    while IFS='|' read -r name fdesc; do
        has_functions=1
        func_output+=$(printf "       ${_HELP_COLOR_ALIAS}%-8s${_HELP_COLOR_RESET} %s\n" "$name" "$fdesc")
        func_output+=$'\n'
    done < <(_help_parse_functions "$alias_file")

    if [[ $has_functions -eq 1 ]]; then
        echo "${_HELP_COLOR_HEADER}FUNKTIONEN${_HELP_COLOR_RESET}"
        printf "%s" "$func_output"
    fi

    if [[ $has_aliases -eq 0 && $has_functions -eq 0 ]]; then
        echo "       ${_HELP_COLOR_DESC}Keine Aliase oder Funktionen gefunden${_HELP_COLOR_RESET}"
        echo ""
    fi

    # Show documentation link if available
    local docs_url=$(_help_get_docs_url "$alias_file")
    if [[ -n "$docs_url" ]]; then
        echo "${_HELP_COLOR_HEADER}SIEHE AUCH${_HELP_COLOR_RESET}"
        echo "       $docs_url"
        echo ""
    fi
}

# Search through all aliases and functions
_help_search() {
    local query="$1"

    if [[ -z "$query" ]]; then
        echo "${_HELP_COLOR_ERROR}‚úñ Bitte Suchbegriff angeben${_HELP_COLOR_RESET}"
        echo "Nutzung: help search <text>"
        return 1
    fi

    _help_print_header "üîç Suche: $query"
    echo ""

    local found=0
    local alias_dir="${HOME}/.config/alias"
    local current_category=""
    local results=""

    for file in "$alias_dir"/*.alias(N); do
        local category=$(_help_get_category "$file")
        local category_results=""

        # Search in aliases
        while IFS='|' read -r name cmd desc; do
            if [[ "${name:l}" =~ "${query:l}" || "${cmd:l}" =~ "${query:l}" || "${desc:l}" =~ "${query:l}" ]]; then
                category_results+=$(printf "       ${_HELP_COLOR_ALIAS}%-8s${_HELP_COLOR_RESET} ${_HELP_COLOR_COMMAND}%s${_HELP_COLOR_RESET}\n" "$name" "$cmd")
                category_results+=$'\n'
                found=1
            fi
        done < <(_help_parse_aliases "$file")

        # Search in functions
        while IFS='|' read -r name desc; do
            if [[ "${name:l}" =~ "${query:l}" || "${desc:l}" =~ "${query:l}" ]]; then
                category_results+=$(printf "       ${_HELP_COLOR_ALIAS}%-8s${_HELP_COLOR_RESET} ${_HELP_COLOR_DESC}%s${_HELP_COLOR_RESET}\n" "$name" "$desc")
                category_results+=$'\n'
                found=1
            fi
        done < <(_help_parse_functions "$file")

        if [[ -n "$category_results" ]]; then
            results+="${_HELP_COLOR_HEADER}${category}${_HELP_COLOR_RESET}"$'\n'
            results+="$category_results"
        fi
    done

    if [[ $found -eq 0 ]]; then
        echo "${_HELP_COLOR_HEADER}ERGEBNIS${_HELP_COLOR_RESET}"
        echo "       Keine Treffer f√ºr '$query'"
        echo ""
    else
        echo "${_HELP_COLOR_HEADER}TREFFER${_HELP_COLOR_RESET}"
        echo ""
        printf "%s" "$results"
    fi
}

# Show installed tools with versions
_help_tools() {
    _help_print_header "üîß Tools"
    echo ""

    echo "${_HELP_COLOR_HEADER}NAME${_HELP_COLOR_RESET}"
    echo "       tools - Installierte CLI-Tools aus dem Brewfile"
    echo ""

    # Define tools to check (from Brewfile)
    local -a tools=(
        "bat:Syntax-Highlighting"
        "eza:Modernes ls"
        "fd:Schnelle Dateisuche"
        "fzf:Fuzzy Finder"
        "rg:Schnelles grep"
        "starship:Shell-Prompt"
        "zoxide:Smartes cd"
        "btop:Ressourcen-Monitor"
        "gh:GitHub CLI"
        "mas:Mac App Store CLI"
    )

    echo "${_HELP_COLOR_HEADER}INSTALLIERT${_HELP_COLOR_RESET}"
    for tool_info in "${tools[@]}"; do
        local tool="${tool_info%%:*}"
        local desc="${tool_info##*:}"
        local version=$(_help_get_tool_version "$tool")

        if [[ "$version" == "not_installed" ]]; then
            printf "       ${_HELP_COLOR_ERROR}‚úñ${_HELP_COLOR_RESET} ${_HELP_COLOR_ALIAS}%-10s${_HELP_COLOR_RESET} ${_HELP_COLOR_DESC}%-10s %s${_HELP_COLOR_RESET}\n" \
                "$tool" "‚Äî" "$desc"
        else
            printf "       ${_HELP_COLOR_SUCCESS}‚úî${_HELP_COLOR_RESET} ${_HELP_COLOR_ALIAS}%-10s${_HELP_COLOR_RESET} ${_HELP_COLOR_COMMAND}%-10s${_HELP_COLOR_RESET} ${_HELP_COLOR_DESC}%s${_HELP_COLOR_RESET}\n" \
                "$tool" "$version" "$desc"
        fi
    done
    echo ""
}

# Interactive fzf mode
_help_interactive() {
    if ! command -v fzf >/dev/null 2>&1; then
        echo "${_HELP_COLOR_ERROR}‚úñ fzf nicht installiert${_HELP_COLOR_RESET}"
        return 1
    fi

    local alias_dir="${HOME}/.config/alias"
    local -a items=()

    # Collect all aliases and functions
    for file in "$alias_dir"/*.alias(N); do
        local category=$(_help_get_category "$file")

        # Add aliases
        while IFS='|' read -r name cmd desc; do
            items+=("[$category] $name|$cmd|$desc")
        done < <(_help_parse_aliases "$file")

        # Add functions
        while IFS='|' read -r name desc; do
            items+=("[$category] $name|(Funktion)|$desc")
        done < <(_help_parse_functions "$file")
    done

    # Show in fzf
    local selection=$(printf '%s\n' "${items[@]}" | \
        fzf --ansi \
            --delimiter='|' \
            --preview 'echo {2} | fold -w 60' \
            --preview-window='down:3:wrap' \
            --header='Enter: Details kopieren | Esc: Beenden' \
            --prompt='Aliase> ')

    if [[ -n "$selection" ]]; then
        # Extract and display selection
        local name=$(echo "$selection" | sed 's/^\[[^]]*\] \([^|]*\).*/\1/')
        local cmd=$(echo "$selection" | cut -d'|' -f2)
        echo ""
        echo "${_HELP_COLOR_SUCCESS}‚úî${_HELP_COLOR_RESET} ${_HELP_COLOR_ALIAS}$name${_HELP_COLOR_RESET} ‚Üí ${_HELP_COLOR_COMMAND}$cmd${_HELP_COLOR_RESET}"
        echo ""
    fi
}

# Pipe output through pager if content is long
_help_with_pager() {
    local content="$1"
    local lines=$(echo "$content" | wc -l | tr -d ' ')
    local term_lines=${LINES:-24}

    # Use pager if output exceeds terminal height
    if (( lines > term_lines - 2 )); then
        # Add navigation hint at the end
        local hint="\n${_HELP_COLOR_DESC}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${_HELP_COLOR_RESET}"
        hint+="\n${_HELP_COLOR_DESC}Navigation: ‚Üë/‚Üì scrollen ‚îÇ q beenden ‚îÇ / suchen${_HELP_COLOR_RESET}"
        content+="$hint"

        if command -v bat >/dev/null 2>&1; then
            echo "$content" | bat --plain --paging=always --style=plain
        else
            echo "$content" | less -R
        fi
    else
        echo "$content"
    fi
}

# Main help function
help() {
    local cmd="${1:-}"
    local arg="${2:-}"

    case "$cmd" in
        "")
            _help_with_pager "$(_help_overview)"
            ;;
        "search")
            _help_with_pager "$(_help_search "$arg")"
            ;;
        "tools")
            _help_with_pager "$(_help_tools)"
            ;;
        "--fzf")
            _help_interactive
            ;;
        *)
            _help_with_pager "$(_help_category "$cmd")"
            ;;
    esac
}
